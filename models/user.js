// Generated by CoffeeScript 1.6.3
(function() {
  var AuthError, Schema, async, http, mongoose, path, schema,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  async = require('async');

  mongoose = require('utils/mongoose');

  Schema = mongoose.Schema;

  schema = new Schema({
    vkontakteId: {
      type: String,
      unique: true,
      required: true
    },
    displayName: {
      type: String,
      required: true
    },
    created: {
      type: Date,
      "default": Date.now
    }
  });

  schema.statics.findOrCreate = function(userData, callback) {
    var User;
    User = this;
    return async.waterfall([
      function(callback) {
        return User.findOne({
          vkontakteId: userData.vkontakteId
        }, callback);
      }, function(user, callback) {
        if (user) {
          return callback(null, user);
        } else {
          user = new User({
            vkontakteId: userData.vkontakteId,
            displayName: userData.displayName
          });
          return user.save(function(err) {
            if (err) {
              return callback(err);
            }
            return callback(null, user);
          });
        }
      }
    ], callback);
  };

  exports.User = mongoose.model('User', schema);

  path = require('path');

  http = require('http');

  AuthError = (function(_super) {
    __extends(AuthError, _super);

    function AuthError(message) {
      this.message = message != null ? message : "Auth Error";
      Error.apply(this, arguments);
      Error.captureStackTrace(this, AuthError);
    }

    return AuthError;

  })(Error);

  exports.AuthError = AuthError;

}).call(this);

/*
//@ sourceMappingURL=user.map
*/
